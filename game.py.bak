# game.py
import random
import pygame as pg
from time import time as now
from typing import Optional

from settings import WIDTH, HEIGHT, FPS, GRID_SIZE, TILE, MARGIN_LEFT, MARGIN_TOP, COLORS
from assets_loader import load_tiles, load_ui
from events import get_random_event, Event

from models import CityState
from config_game import (
    CATALOG, BUILD_EFFECTS, TOOLTIPS,
    ROAD_ONEOFF_POWER, ROAD_ONEOFF_WATER,
    MIN_WITHDRAW_THRESHOLD, WITHDRAW_COOLDOWN_S
)
from grid_system import (
    make_grid, grid_to_px, px_to_grid,
    place_build, demolish_at, count_buildings_by_tile_connected,
    recompute_connectivity, has_building
)
from economy import (
    recompute_resources, refresh_treasury_cap, update_labor_market,
    income_tick_per_second, inflation_hourly, socio_env_hourly,
    upkeep_minutely, decay_oneoff_resources, central_bank_connected,
    update_happiness_daily
)
from ui_draw import (
    draw_topbar, draw_category_menu, draw_submenu,
    draw_tooltip, draw_text, draw_panel
)

def run_game():
    pg.init()
    screen = pg.display.set_mode((WIDTH, HEIGHT))
    pg.display.set_caption("City Builder — vSim")
    clock = pg.time.Clock()

    tiles = load_tiles(tile_size=(TILE, TILE))
    ui    = load_ui()
    get_tile_img = lambda key: tiles.get(key, tiles.get("empty"))

    # ----- estado
    grid  = make_grid()
    state = CityState()
    def sync_population_scalar():
        state.population = max(0, state.pop_young + state.pop_adult + state.pop_elder)

    # tempo
    paused = False
    speed  = 1.0
    day, month, year = 1, 1, 1
    hour, minute = 8, 0
    sec_accum = 0.0
    game_seconds_total = 0

    # seleção
    active_category: Optional[str] = None
    selected_build: Optional[str]  = None
    suppress_click_until_ms = 0

    long_press_ms   = 600
    mouse_down_time = None
    painting_roads  = False

    # eventos
    current_event: Optional[Event] = None
    event_visible = False
    def schedule_next_event(y, m, d, h):
        add_days = random.randint(1, 3)
        hour_t   = random.randint(7, 21)
        y2, m2, d2 = y, m, d + add_days
        while d2 > 30: d2 -= 30; m2 += 1
        while m2 > 12: m2 = 1; y2 += 1
        return (y2, m2, d2, hour_t)
    next_event_at = schedule_next_event(year, month, day, hour)
    is_due = lambda cur, tgt: (cur[0]>tgt[0]) or (cur[0]==tgt[0] and (cur[1]>tgt[1] or (cur[1]==tgt[1] and (cur[2]>tgt[2] or (cur[2]==tgt[2] and cur[3]>=tgt[3])))))

    # mensagens (toasts)
    messages: list[dict] = []
    def push_message(text: str, ttl: float = 2.5, color=(240, 80, 80)):
        messages.append({"text": text, "ttl": ttl, "color": color})
    def update_messages(dt: float):
        for m in messages: m["ttl"] -= dt
        while messages and messages[0]["ttl"] <= 0: messages.pop(0)
    def draw_messages():
        if not messages: return
        TOPBAR_H = 100; PADDING = 12
        base_y = TOPBAR_H + PADDING + 12
        x_center = WIDTH // 2
        for i, m in enumerate(messages[:3]):
            text_w = pg.font.SysFont(None, 22).size(m["text"])[0]
            w = min(WIDTH - 160, text_w + 40); h = 38
            rx = x_center - w//2; ry = int(base_y + i*(h+8))
            r = draw_panel(screen, rx, ry, w, h, fill=(255,255,255), border=(210,230,245), radius=10)
            draw_text(screen, m["text"], r.centerx, r.centery-1, size=22, color=m["color"], center=True)

    # população por prédio
    population_by_gid: dict[str, tuple[int,int,int]] = {}
    def add_population_random(gid: str, name: str):
        if name == "Casa":
            total = random.randint(1, 6)
        elif name == "Condomínio":
            total = random.randint(7, 15)
        else:
            return
        young = int(round(total * random.uniform(0.25, 0.40)))
        elder = int(round(total * random.uniform(0.08, 0.15)))
        adult = max(0, total - young - elder)
        state.pop_young += young; state.pop_adult += adult; state.pop_elder += elder
        sync_population_scalar()
        population_by_gid[gid] = (young, adult, elder)

    def remove_population_gid(gid: str):
        tup = population_by_gid.pop(gid, None)
        if not tup: return
        y,a,e = tup
        state.pop_young = max(0, state.pop_young - y)
        state.pop_adult = max(0, state.pop_adult - a)
        state.pop_elder = max(0, state.pop_elder - e)
        sync_population_scalar()

    # conectividade inicial
    connected_roads, connected_gids = recompute_connectivity(grid)

    # economia inicial
    refresh_treasury_cap(state, grid, connected_gids)
    jobs_com = jobs_ind = jobs_farm = labor_total = labor_com = labor_ind = labor_farm = 0
    jobs_com, jobs_ind, jobs_farm, labor_total, labor_com, labor_ind, labor_farm = update_labor_market(state, grid, connected_gids)
    recompute_resources(state, grid, connected_gids)

    # saque
    last_withdraw_game_s = -9999
    auto_tax = False
    def can_withdraw_now():
        nonlocal last_withdraw_game_s
        com  = count_buildings_by_tile_connected(grid, connected_gids, "commercial")
        ind  = count_buildings_by_tile_connected(grid, connected_gids, "industrial")
        farm = count_buildings_by_tile_connected(grid, connected_gids, "farm")
        if (com + ind + farm) == 0:
            return False, "É preciso ao menos 1 Comércio/Indústria/Fazenda conectados à Prefeitura."
        if state.treasury_pending < MIN_WITHDRAW_THRESHOLD:
            return False, f"Sem riqueza suficiente (mínimo ${int(MIN_WITHDRAW_THRESHOLD)})."
        cd = WITHDRAW_COOLDOWN_S - (10 if central_bank_connected(state, grid, connected_gids) else 0)
        cd = max(10, cd)
        if (game_seconds_total - last_withdraw_game_s) < cd:
            return False, f"Aguarde cooldown ({int(cd - (game_seconds_total - last_withdraw_game_s))}s)."
        return True, None

    def perform_withdraw(auto=False):
        nonlocal last_withdraw_game_s
        payout = state.treasury_pending * max(0.0, 1.0 - state.inflation/100.0)
        if auto: payout *= 0.98
        add = int(payout)
        state.money += add
        push_message(f"Receita coletada: ${add}" + (" (auto)" if auto else ""), ttl=2.5, color=(40,140,90))
        state.treasury_pending = 0.0
        last_withdraw_game_s = game_seconds_total

    # hover/tooltip
    TOOLTIP_DELAY_MS = 300
    hover_key = None
    hover_start_ms = 0

    running = True
    pause_btn_rect = withdraw_btn_rect = auto_btn_rect = None
    cat_rects = []; submenu_rects = []; submenu_disabled_map = {}

    while running:
        dt = clock.tick(FPS) / 1000.0

        for e in pg.event.get():
            if e.type == pg.QUIT:
                running = False
            elif e.type == pg.KEYDOWN:
                if e.key == pg.K_ESCAPE:
                    if active_category is not None:
                        active_category = None
                        suppress_click_until_ms = pg.time.get_ticks() + 200
                    else:
                        running = False
                elif e.key == pg.K_SPACE:
                    paused = not paused
                elif e.key == pg.K_F1: speed = 1.0
                elif e.key == pg.K_F2: speed = 2.0
                elif e.key == pg.K_F3: speed = 5.0
            elif e.type == pg.MOUSEBUTTONDOWN and e.button == 1:
                mouse_down_time = pg.time.get_ticks()
                mx, my = pg.mouse.get_pos()
                # categorias
                for r, cat_key in cat_rects:
                    if r.collidepoint(mx, my):
                        active_category = cat_key if active_category != cat_key else None
                        if active_category is None:
                            suppress_click_until_ms = pg.time.get_ticks() + 200
                        break
                # submenu
                if active_category and submenu_rects:
                    clicked = False
                    for r, name in submenu_rects:
                        if r.collidepoint(mx, my):
                            if name in submenu_disabled_map:
                                push_message(submenu_disabled_map[name], ttl=2.5, color=(200,100,80))
                            else:
                                selected_build = name
                                active_category = None
                                suppress_click_until_ms = pg.time.get_ticks() + 200
                            clicked = True
                            break
                    if clicked: continue
                # botões topo
                if pause_btn_rect and pause_btn_rect.collidepoint(mx, my):
                    paused = not paused; continue
                if withdraw_btn_rect and withdraw_btn_rect.collidepoint(mx, my):
                    ok, reason = can_withdraw_now()
                    if ok: perform_withdraw()
                    else:  push_message(reason, ttl=2.5, color=(220, 80, 80))
                    continue
                if auto_btn_rect and auto_btn_rect.collidepoint(mx, my):
                    auto_tax = not auto_tax
                    push_message("Auto-saque " + ("ON" if auto_tax else "OFF"), ttl=1.5, color=(80,140,200))
                    continue
                # arrasto de ruas
                if selected_build == "Rua":
                    painting_roads = True
            elif e.type == pg.MOUSEBUTTONUP and e.button == 1:
                held = pg.time.get_ticks() - (mouse_down_time or pg.time.get_ticks())
                mouse_down_time = None
                painting_roads = False
                mx, my = pg.mouse.get_pos()
                gpos = px_to_grid(mx, my)
                if not gpos: continue
                if pg.time.get_ticks() < suppress_click_until_ms:
                    continue
                gx, gy = gpos
                if event_visible and current_event: continue
                if held > long_press_ms and grid[gy][gx].occupied:
                    gid = demolish_at(grid, gx, gy)
                    if gid:  # atualizar população
                        # remover população se residencial
                        from grid_system import count_all
                        remove_population_gid(gid)
                    connected_roads, connected_gids = recompute_connectivity(grid)
                    refresh_treasury_cap(state, grid, connected_gids)
                    recompute_resources(state, grid, connected_gids)
                    continue
                if not selected_build:
                    push_message("Escolha uma construção no menu.", ttl=1.8, color=(200,140,60))
                else:
                    # requisitos de custo/infra
                    reqs = CATALOG.get(selected_build, {}).get("requires", [])
                    for req in reqs:
                        if not has_building(grid, req):
                            push_message(f"Requer {req}.", ttl=2.0); break
                    else:
                        cost = -BUILD_EFFECTS.get(selected_build, {}).get("money", 0)
                        if state.money < cost:
                            push_message("Dinheiro insuficiente.", ttl=2.0); continue
                        ok, res = place_build(grid, gx, gy, selected_build)
                        if not ok:
                            push_message(res or "Falha ao construir.", ttl=2.0)
                        else:
                            state.money -= cost
                            if selected_build in ("Casa","Condomínio"): add_population_random(res, selected_build)
                            if selected_build == "Rua":
                                state.power_use_once += ROAD_ONEOFF_POWER
                                state.water_use_once += ROAD_ONEOFF_WATER
                            connected_roads, connected_gids = recompute_connectivity(grid)
                            refresh_treasury_cap(state, grid, connected_gids)
                            recompute_resources(state, grid, connected_gids)
            elif e.type == pg.MOUSEMOTION and painting_roads and selected_build == "Rua":
                mx, my = e.pos
                gpos = px_to_grid(mx, my)
                if gpos:
                    gx, gy = gpos
                    if not grid[gy][gx].occupied:
                        cost = -BUILD_EFFECTS.get("Rua", {}).get("money", 0)
                        if state.money < cost:
                            push_message("Dinheiro insuficiente.", ttl=2.0)
                            painting_roads = False
                        else:
                            ok, _ = place_build(grid, gx, gy, "Rua")
                            if ok:
                                state.money -= cost
                                state.power_use_once += ROAD_ONEOFF_POWER
                                state.water_use_once += ROAD_ONEOFF_WATER
                                connected_roads, connected_gids = recompute_connectivity(grid)
                                recompute_resources(state, grid, connected_gids)

        # tempo
        if not paused:
            sec_accum += dt * speed
            while sec_accum >= 1.0:
                sec_accum -= 1.0
                game_seconds_total += 1

                income_tick_per_second(state, grid, connected_gids)

                minute += 1
                if minute >= 60:
                    minute = 0
                    hour += 1
                    decay_oneoff_resources(state)
                    recompute_resources(state, grid, connected_gids)
                    inflation_hourly(state, grid, connected_gids)
                    socio_env_hourly(state, grid, connected_gids)
                    if hour >= 24:
                        hour = 0; day += 1
                        # aging anual simples
                        if day == 1 and month == 1:
                            y2a = round(state.pop_young * 0.20)
                            a2e = round(state.pop_adult * 0.04)
                            e2out = round(state.pop_elder * 0.06)
                            state.pop_young = max(0, state.pop_young - y2a)
                            state.pop_adult = max(0, state.pop_adult + y2a - a2e)
                            state.pop_elder = max(0, state.pop_elder + a2e - e2out)
                            sync_population_scalar()
                        # auto-saque
                        if auto_tax:
                            ok,_ = can_withdraw_now()
                            if ok: perform_withdraw(auto=True)
                        # felicidade diária
                        update_happiness_daily(state, grid, connected_gids, GRID_SIZE)
                        if day > 30:
                            day = 1; month += 1
                            if month > 12: month = 1; year += 1

                # alfabetização: +0.2 pt/h se houver universidade conectada
                if count_buildings_by_tile_connected(grid, connected_gids, "university") > 0:
                    state.literacy = min(100.0, state.literacy + (0.2/60.0))

                upkeep_minutely(state, grid)

        update_messages(dt)

        # ===== DRAW =====
        screen.fill(COLORS["bg"])

        # topbar
        def _canw(): return can_withdraw_now()
        pause_btn_rect, withdraw_btn_rect, rect_map = draw_topbar(
            screen, ui, COLORS, state, day, month, year, hour, minute,
            paused, _canw, auto_tax
        )
        auto_btn_rect = rect_map.get("auto_tax")

        # grid
        mx, my = pg.mouse.get_pos()
        hover = px_to_grid(mx, my)
        for y in range(GRID_SIZE):
            for x in range(GRID_SIZE):
                px, py = grid_to_px(x, y)
                key = grid[y][x].btype if grid[y][x].occupied else "empty"
                img = get_tile_img(key)
                if img: screen.blit(img, (px, py))
                pg.draw.rect(screen, COLORS["grid"], pg.Rect(px, py, TILE, TILE), width=1, border_radius=4)

        # preview de construção
        if hover and (not event_visible) and selected_build:
            hx, hy = hover
            cfg = CATALOG[selected_build]
            for j in range(cfg["h"]):
                for i in range(cfg["w"]):
                    x = hx + i; y = hy + j
                    if 0 <= x < GRID_SIZE and 0 <= y < GRID_SIZE:
                        px, py = grid_to_px(x, y)
                        pg.draw.rect(screen, COLORS["preview"], pg.Rect(px, py, TILE, TILE), width=2, border_radius=4)

        # rodapé + submenu (injeta grid no catálogo p/ verificação de requisitos)
        cat_rects = draw_category_menu(screen, ui, active_category)

        submenu_rects, submenu_disabled_map = ([], {})
        if active_category:
            submenu_rects, submenu_disabled_map = draw_submenu(screen, ui, CATALOG, active_category)

        # eventos/dilemas
        if event_visible and current_event:
            panel = draw_panel(screen, WIDTH//2 - 320, HEIGHT//2 - 160, 640, 320)
            draw_text(screen, "DILEMA", panel.centerx, panel.top + 22, size=28, color=(30,60,100), center=True)
            draw_text(screen, current_event.title, panel.left + 24, panel.top + 58, size=22, color=(30,50,70))
            draw_text(screen, current_event.desc, panel.left + 24, panel.top + 88, size=20, color=(40,60,80))
            a_label = list(current_event.options.keys())[0]
            b_label = list(current_event.options.keys())[1]
            draw_text(screen, f"A) {a_label}", panel.left + 24, panel.top + 148, size=20, color=(20,40,60))
            draw_text(screen, f"B) {b_label}", panel.left + 24, panel.top + 178, size=20, color=(20,40,60))
            draw_text(screen, "Pressione A ou B", panel.centerx, panel.bottom - 28, size=18, color=(80,110,140), center=True)

        # toasts
        draw_messages()

        # tooltips
        TOOLTIP_DELAY_MS = 300
        hovered_any = False
        for key, r in rect_map.items():
            if r.collidepoint(mx, my):
                if key != "hover_key":
                    hover_key = key; hover_start_ms = pg.time.get_ticks()
                hovered_any = True; break
        if not hovered_any:
            hover_key = None
        if hover_key and (pg.time.get_ticks() - hover_start_ms >= TOOLTIP_DELAY_MS):
            from ui_draw import tooltip_text_for_key
            tip = tooltip_text_for_key(hover_key, state, jobs_com, jobs_ind, labor_com, labor_ind, _canw)
            if tip: draw_tooltip(screen, tip, (mx, my))

        pg.display.flip()

    pg.quit()
